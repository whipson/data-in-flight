{
  "hash": "9a8f020265e592667a06c2f2b1476a30",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Announcing... schematic\"\nsubtitle: \"A new solution for data validation with a focus on user-facing messages\"\nauthor: \"Will Hipson\"\ndate: \"2025-04-28\"\ndate-modified: last-modified\ncategories: [data-cleaning, R, packages, release, schematic]\n---\n\nI'm thrilled to announce the release of `schematic`, an R package that helps *you* (the developer) communicate data validation problems to non-technical users. With schematic, you can leverage `tidyselect` selectors and other conveniences to compare incoming data against a schema, avoiding punishing issues caused by invalid or poor quality data.\n\nschematic can now be installed via CRAN:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"schematic\")\n```\n:::\n\nLearn more about schematic by checking out the [docs](https://whipson.github.io/schematic/).\n\n## Motivation\n\nHaving built and deployed a number of shiny apps or APIs that require users to upload data, I noticed a common pain point: **how do I communicate in simple terms any issues with the data and, more importantly, what those issues are?** I needed a way to present the user with error messages that satisfy two needs:\n\n1.  Simple and non-technical: allow developers to explain the problem rather than forcing users to understand the technical aspects of each test (you don't want to have to explain to users what `is.logical` means).\n2.  Holistic checking: present all validation issues rather than stopping evaluation on the first failure.\n\nThere already exists a number of data validation packages for R, including (but not limited to) [pointblank](https://rstudio.github.io/pointblank/), [data.validator](http://appsilon.github.io/data.validator/), and [validate](https://github.com/data-cleaning/validate?tab=readme-ov-file); so why introduce a new player? schematic certainly shares similarities with many of these packages, but where I think it innovates over existing solutions is in its unique combination of the following:\n\n1.  Lightweight: Minimal dependencies with a clear focus on checking data without the bells and whistles of graphics, tables, and whatnot.\n2.  User-focused but developer-friendly: Developers (especially those approaching from a tidyverse mentality) will like the expressive syntax; users will appreciate the informative instructions on how to comprehensively fix data issues (no more whack-a-mole with fixing one problem only to learn there are many others).\n3.  Easy to integrate into applications (e.g., Shiny, Plumber): Schematic returns error messages rather than reports or data.frames, meaning that you don't need additional logic to trigger a run time error; just pass along the error message in a notification or error code.\n\n## How it works\n\n::: callout-warning\nAll R errors that appear in this post are intentional for the purpose of demonstrating schematic's error messaging.\n:::\n\nSchematic is extremely simple. You only need to do two things: create a schema and then check a data.frame against the schema.\n\nA schema is a set of rules for columns in a data.frame. A rule consists of two parts:\n\n1.  **Selector** - the column(s) on which to apply to rule\n2.  **Predicate** - a function that must return a single TRUE or FALSE indicating the pass or fail of the check\n\nLet's imagine a scenario where we have survey data and we want to ensure it matches our expectations. Here's some sample survey data:\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey_data <- data.frame(\n  id = c(1:3, NA, 5),\n  name = c(\"Emmett\", \"Billy\", \"Sally\", \"Woolley\", \"Duchess\"),\n  age = c(19.2, 10, 22.5, 19, 19),\n  sex = c(\"M\", \"M\", \"F\", \"M\", NA),\n  q_1 = c(TRUE, FALSE, FALSE, FALSE, TRUE),\n  q_2 = c(FALSE, FALSE, TRUE, TRUE, TRUE),\n  q_3 = c(TRUE, TRUE, TRUE, TRUE, FALSE)\n)\n```\n:::\n\nWe declare a schema using `schema()` and provide it with rules following the format `selector ~ predicate`:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(schematic)\n\nmy_schema <- schema(\n  id ~ is_incrementing,\n  id ~ is_all_distinct,\n  c(name, sex) ~ is.character,\n  c(id, age) ~ is_whole_number,\n  education ~ is.factor,\n  sex ~ function(x) all(x %in% c(\"M\", \"F\")),\n  starts_with(\"q_\") ~ is.logical,\n  final_score ~ is.numeric\n)\n```\n:::\n\nThen we use `check_schema` to evaluate our data against the schema. Any and all errors will be captured in the error message:\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_schema(\n  data = survey_data,\n  schema = my_schema\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `check_schema()`:\n! Schema Error:\n- Columns `education` and `final_score` missing from data\n- Column `id` failed check `is_incrementing`\n- Column `age` failed check `is_whole_number`\n- Column `sex` failed check `function(x) all(x %in% c(\"M\", \"F\"))`\n```\n\n\n:::\n:::\n\nThe error message will combine columns into a single statement if they share the same validation issue. schematic will also automatically report if any columns declared in the schema are missing from the data.\n\n## Customizing the message\n\nBy default the error message is helpful for developers, but if you need to communicate the schema mismatch to a non-technical person they'll have trouble understanding some or all of the errors. You can customize the output of each rule by inputting the rule as a named argument.\n\nLet's fix up the previous example to make the messages more understandable.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_helpful_schema <- schema(\n  \"values are increasing\" = id ~ is_incrementing,\n  \"values are all distinct\" = id ~ is_all_distinct,\n  \"is a string\" = c(name, sex) ~ is.character,\n  \"is a string with specific levels\" = education ~ is.factor,\n  \"is a whole number (no decimals)\" = c(id, age) ~ is_whole_number,\n  \"has only entries 'F' or 'M'\" = sex ~ function(x) all(x %in% c(\"M\", \"F\")),\n  \"includes only TRUE or FALSE\" = starts_with(\"q_\") ~ is.logical,\n  \"is a number\" = final_score ~ is.numeric\n)\n\ncheck_schema(\n  data = survey_data,\n  schema = my_helpful_schema\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `check_schema()`:\n! Schema Error:\n- Columns `education` and `final_score` missing from data\n- Column `id` failed check `values are increasing`\n- Column `age` failed check `is a whole number (no decimals)`\n- Column `sex` failed check `has only entries 'F' or 'M'`\n```\n\n\n:::\n:::\n\nAnd that's really all there is to it. schematic does come with a few handy predicate functions like `is_whole_number()` which is a more permissive version of `is.integer()` that allows for columns stored as numeric or double but still requires non-decimal values.\n\nMoreover, schematic includes a handful of modifiers that allow you to change the behavior of some predicates, for instance, allowing NAs with `mod_nullable()`:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Before using `mod_nullable()` this rule triggered an error\nmy_schema <- schema(\n  \"all values are increasing (except empty values)\" = id ~ mod_nullable(is_incrementing)\n)\n\ncheck_schema(\n  data = survey_data,\n  schema = my_schema\n)\n```\n:::\n\n## Conclusion\n\nIn the end, my hope is to make schematic as simple as possible and help both developers and users. It's a package I designed initially with the sole intention of saving myself from writing validation code that takes up 80% of the actual codebase.[^1] I hope you find it useful too.\n\n[^1]: Not an exaggeration. I have a Plumber API that allows users to POST data to be processed. 80% of that plumber code is to validate the incoming data.\n\n#### Notes\n\nThis post was created using R version 4\\.5\\.0 \\(2025\\-04\\-11\\) and schematic version 0.1.0.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}