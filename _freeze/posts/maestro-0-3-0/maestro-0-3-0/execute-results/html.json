{
  "hash": "559dea089c2c8991678d8ad7345d746c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"maestro 0.3.0\"\nsubtitle: New methods for getting schedule status and return values from pipelines\nauthor: \"Will Hipson\"\ndate: \"2024-09-23\"\ndate-modified: last-modified\ncategories: [R, data pipelines, orchestration, maestro, packages, release]\n---\n\n\n\n![](images/logo.png){fig-align=\"center\"}\n\n`maestro` 0.3.0 introduces principled methods for obtaining a schedule table, pipeline status, and artifacts (i.e., return values). This is now possible because of a major refactoring of the backend to use R6 classes for pipelines and schedules. This also introduced a few breaking changes, but on the whole, not a lot is different.\n\nIf you haven't heard of maestro, it's a package that helps you schedule your R scripts all in a single project using tags. You can learn more about it [here](../hello-maestro/hello-maestro.qmd).\n\nGet it from CRAN:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maestro\")\n```\n:::\n\n\n\n## A schedule is now a \\<MaestroSchedule\\>\n\nSchedules are now a special class with attributes and methods. For most users, this won't change how they use maestro, but it'll make it much easier to extend maestro with new features in the future. Let's see how a typical maestro scenario plays out now:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(maestro)\n\n# Create a few dummy pipelines for demo purposes\ncreate_pipeline(\n  \"my_pipe\", open = FALSE, quiet = TRUE, overwrite = TRUE\n  )\ncreate_pipeline(\n  \"my_pipe2\", frequency = \"1 week\", open = FALSE, quiet = TRUE, overwrite = TRUE\n  )\ncreate_pipeline(\n  \"my_pipe3\", frequency = \"2 hours\", open = FALSE, quiet = TRUE, overwrite = TRUE\n  )\n\nschedule <- build_schedule(quiet = TRUE)\n\noutput <- run_schedule(\n  schedule,\n  orch_frequency = \"hourly\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── [2024-09-23 14:31:34]\nRunning pipelines ▶ \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ my_pipe3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ my_pipe3 [8ms]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── [2024-09-23 14:31:34]\nPipeline execution completed ■ | 0.101 sec elapsed \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ 1 success | → 2 skipped | ! 0 warnings | ✖ 0 errors | ◼ 3 total\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n────────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Next scheduled pipelines ❯ \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPipe name | Next scheduled run\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• my_pipe3 | 2024-09-23 20:00:00\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• my_pipe | 2024-09-24\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• my_pipe2 | 2024-09-30\n```\n\n\n:::\n:::\n\n\n\nSo far these are the same steps as before. The difference is now in how we interact with the schedule. Here, `schedule` is no longer a data.frame, it's a `<MaestroSchedule>` R6 object. If we want to get the status of each of the pipelines, we can use the new `get_status()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_status(schedule)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 10\n  pipe_name script_path  invoked success pipeline_started    pipeline_ended     \n  <chr>     <chr>        <lgl>   <lgl>   <dttm>              <dttm>             \n1 my_pipe   ./pipelines… FALSE   FALSE   NA                  NA                 \n2 my_pipe2  ./pipelines… FALSE   FALSE   NA                  NA                 \n3 my_pipe3  ./pipelines… TRUE    TRUE    2024-09-23 17:31:34 2024-09-23 17:31:34\n# ℹ 4 more variables: errors <int>, warnings <int>, messages <int>,\n#   next_run <dttm>\n```\n\n\n:::\n:::\n\n\n\nIf we just want the schedule, we can use `get_schedule()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_schedule(schedule)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 9\n  script_path      pipe_name frequency start_time          tz    skip  log_level\n  <chr>            <chr>     <chr>     <dttm>              <chr> <lgl> <chr>    \n1 ./pipelines/my_… my_pipe   1 day     2024-09-23 00:00:00 UTC   FALSE INFO     \n2 ./pipelines/my_… my_pipe2  1 week    2024-09-23 00:00:00 UTC   FALSE INFO     \n3 ./pipelines/my_… my_pipe3  2 hours   2024-09-23 00:00:00 UTC   FALSE INFO     \n# ℹ 2 more variables: frequency_n <int>, frequency_unit <chr>\n```\n\n\n:::\n:::\n\n\n\nNote that we didn't have to assign a new object when we ran `run_schedule()`. The object `schedule` is updated to reflect the execution of the schedule.\n\nIf any pipelines have return values, we can access those as a named list using `get_artifacts()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_artifacts(schedule)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnamed list()\n```\n\n\n:::\n:::\n\n\n\n## Invoking a pipeline\n\nWhen interactively working in a maestro project, it may sometimes be useful to manually trigger a pipeline. Now, if you've created a `<MaestroSchedule>` object in the environment, you can do this using `invoke()`. This will execute the pipeline regardless of whether it's scheduled or not.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninvoke(schedule, pipe_name = \"my_pipe\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ my_pipe\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ my_pipe [6ms]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n:::\n\n\n\nCheck out the [release notes](https://whipson.github.io/maestro/news/index.html) for more details on what's new in version 0.3.0. If you find any bugs or want to suggest new features and improvements, please add them [here](https://github.com/whipson/maestro/issues) or reach out to me on [LinkedIn](https://www.linkedin.com/in/will-hipson/).\n\nHappy orchestrating!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}