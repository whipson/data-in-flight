{
  "hash": "997d87dfdbb434070bd3dd7bbc531553",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"maestro 0.6.0\"\nsubtitle: New capabilities for flagging pipelines, setting priorities, and optimizing your orchestration\nauthor: \"Will Hipson\"\ndate: \"2025-05-15\"\ndate-modified: last-modified\ncategories: [R, data pipelines, orchestration, maestro, packages, release]\n---\n\n![](images/clipboard-2853204278.png){fig-align=\"center\"}\n\nThere are a bunch of new features to share as part of the 0.6.0 release of `maestro`:\n\n1.  `maestroFlags` tag and accompanying `get_flags()` function for tagging pipelines.\n2.  `maestroPriority` tag for determining the order in which simultaneously scheduled pipelines are executed.\n3.  New `get_slot_usage()` function to help identify busy (or quiet) time slots in the schedule.\n4.  `maestroStartTime` tag is more flexible to allow for HH:MM:SS formats.\n\nIf you haven't heard of maestro, it's a package that helps you schedule your R scripts all in a single project using tags. You can learn more about it [here](../hello-maestro/hello-maestro.qmd).\n\nGet it from CRAN:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maestro\")\n```\n:::\n\n## Flags\n\nA flag is an arbitrary string that could be used to classify or label a pipeline.[^1] You can now add any number of flags to a pipeline using the `maestroFlags` tag like so:\n\n[^1]: Perhaps a more appropriate name for this concept is **tag**. However, it would be confusing to have a maestro tag that is itself called maestroTags.\n\n::: {.cell}\n\n```{.r .cell-code}\n# ./pipelines\n\n# You could use tags to classify a pipeline as critical\n#' @maestroFrequency 1 day\n#' @maestroStartTime 2024-06-03\n#' @maestroFlags critical \nsuper_important <- function() {\n  # Obv. does something important\n}\n\n# You can have as many flags as you want separated by spaces\n#' @maestroFrequency hourly\n#' @maestroStartTime 2025-04-05 12:30:00\n#' @maestroFlags aviation api-access\nairlines <- function() {\n  # Accesses airlines from an API or whatever\n}\n```\n:::\n\nOnce you've flagged some pipelines, you can access the flags for all pipelines in the schedule as a data.frame using `get_flags()`.\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(maestro)\n\nschedule <- build_schedule(quiet = TRUE)\n\nget_flags(schedule)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  pipe_name       flag      \n  <chr>           <chr>     \n1 super_important critical  \n2 airlines        aviation  \n3 airlines        api-access\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\nThis table could be used, for example, to send statuses reports to particular groups based on the tags, or trigger warnings/errors based on the criticality of the pipelines that failed. In these cases, it's helpful to join the table with either `get_status()` or `get_schedule()`.\n\n## Priority\n\nSometimes you have multiple pipelines that run at the same time - say, if you have two hourly pipelines running on the same cadence. You may want to control the order in which these pipelines are executed[^2]. The new `maestroPriority` tag allows you to configure the priority in which pipelines are executed:\n\n[^2]: This is not the same as having a DAG pipeline where pipelines are chained together.\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @maestroFrequency 1 hour\n#' @maestroStartTime 10:00:00\nim_less_important <- function() {\n  # some less important stuff\n}\n\n#' @maestroFrequency 1 hour\n#' @maestroStartTime 10:00:00\n#' @maestroPriority 1\ni_go_first <- function() {\n  # this needs to happen first\n}\n```\n:::\n\nThese pipelines run every hour on the 00 minute. The second pipeline has `maestroPriority 1`, indicating that it goes first when the orchestrator kicks off the pipelines. Pipelines without a priority always go last and pipelines with the same priority level use default ordering (alphabetical by script path name and then line number) within their own priority level.\n\n## Slot Usage\n\nAs a maestro project grows it can become increasingly difficult to know when is the best time to schedule a pipeline. You typically want to avoid scheduling a bunch of pipelines at the same time (unless they *need* to be executed together or at that particular time), and you don't want a ton of empty time slots (i.e., times where the orchestrator kicks off no pipelines).\n\nBehold, the `get_slot_usage()` function!\n\nThis function looks ahead to all scheduled runs of pipelines in the project and returns a data.frame indicating the pipelines that are scheduled to run on each time slot. It's easier to understand how this works in practice.\n\nLet's create a bunch of pipelines first:\n\n::: {.cell}\n\n```{.r .cell-code}\n#' ./pipelines\n#' @maestroFrequency hourly\n#' @maestroStartTime 14:00:00\nhourly <- function() {\n  \n}\n\n#' @maestroFrequency daily\n#' @maestroStartTime 14:00:00\ndaily <- function() {\n  \n}\n\n#' @maestroFrequency 3 hours\n#' @maestroStartTime 00:00:00\nevery_3_hours <- function() {\n  \n}\n\n#' @maestroFrequency weekly\n#' @maestroStartTime 2025-05-15 04:00:00\nweekly <- function() {\n  \n}\n\n#' @maestroFrequency daily\n#' @maestroDays 4 9 16 20\nsome_days <- function() {\n  \n}\n```\n:::\n\n::: {.cell}\n\n:::\n\nIn this example we're considering running the orchestrator every 1 hour and we want to see for each hour time slot what pipelines are scheduled to run:\n\n::: {.cell}\n\n```{.r .cell-code}\nschedule <- build_schedule(quiet = TRUE)\n\nget_slot_usage(\n  schedule,\n  orch_frequency = \"1 hour\",\n  slot_interval = \"hour\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 3\n   slot  n_runs pipe_names                      \n   <chr>  <int> <chr>                           \n 1 00:00      3 hourly, every_3_hours, some_days\n 2 01:00      1 hourly                          \n 3 02:00      1 hourly                          \n 4 03:00      2 hourly, every_3_hours           \n 5 04:00      2 hourly, weekly                  \n 6 05:00      1 hourly                          \n 7 06:00      2 hourly, every_3_hours           \n 8 07:00      1 hourly                          \n 9 08:00      1 hourly                          \n10 09:00      2 hourly, every_3_hours           \n# ℹ 14 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\nWe can see that things are fairly evenly distributed aside from the hour 00 which has 3 pipelines scheduled. There are also many times where only 1 pipeline runs, so if we have a pipeline that runs daily we'd want to schedule it at a less busy time.\n\nWe can change the `slot_interval` argument to any other valid unit of time to get a different picture.\n\n::: {.cell}\n\n```{.r .cell-code}\nget_slot_usage(\n  schedule,\n  orch_frequency = \"1 hour\",\n  slot_interval = \"day\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 31 × 3\n   slot  n_runs pipe_names                                     \n   <chr>  <int> <chr>                                          \n 1 01         4 hourly, daily, every_3_hours, weekly           \n 2 02         4 hourly, daily, every_3_hours, weekly           \n 3 03         4 hourly, daily, every_3_hours, weekly           \n 4 04         5 hourly, daily, every_3_hours, weekly, some_days\n 5 05         4 hourly, daily, every_3_hours, weekly           \n 6 06         4 hourly, daily, every_3_hours, weekly           \n 7 07         4 hourly, daily, every_3_hours, weekly           \n 8 08         4 hourly, daily, every_3_hours, weekly           \n 9 09         5 hourly, daily, every_3_hours, weekly, some_days\n10 10         4 hourly, daily, every_3_hours, weekly           \n# ℹ 21 more rows\n```\n\n\n:::\n:::\n\nA few things to consider when using `get_slot_usage()`:\n\n1.  It looks at all future instances of when a pipeline will run not just the next unit of time. In the last example, a weekly pipeline appears to run every day but it's just because all those days on any given month and year will involve running that pipeline.\n2.  Usually you should keep `orch_frequency` the same as it is in your use of `run_schedule()`, but `slot_interval` could depend on what frequency a new pipeline is. In general, you should use one more frequency unit of time than your proposed pipeline. For example, if you're planning a daily pipeline, use `slot_interval = \"hour\"` to identify what hour it should on.\n3.  This function is meant to be used interactively when you're developing a `maestro` project. It doesn't serve much value running in production.\n\n## Flexible Start Time\n\nA minor improvement was made to the `maestroStartTime` tag to allow the use of HH:MM:SS formatting for timestamps. This is particularly useful if you have a pipeline that runs hourly or more frequent because the choice of start date was arbitrary. It'll assume that the pipeline start date is the current date that the schedule was built.\n\n## Conclusion\n\nCheck out the [release notes](https://whipson.github.io/maestro/news/index.html) for more details on what's new in version 0.6.0. If you find any bugs or want to suggest new features and improvements, please add them [here](https://github.com/whipson/maestro/issues) or reach out to me on [LinkedIn](https://www.linkedin.com/in/will-hipson/).\n\nHappy orchestrating!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}